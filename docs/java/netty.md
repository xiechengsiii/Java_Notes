### Netty 相关

#### 前置知识

##### 阻塞/非阻塞IO与异步/同步

- 一个关于进程切换的示例图

  ![img](https://pic1.zhimg.com/80/v2-5672054f97fd77f78420fed6b442536e_1440w.jpg?source=1940ef5c)

当发生中断或者系统调用时，CPU的控制权会从当前进程转移到操作系统内核。操作系统在进行进程切换时，需要进行一系列的内存读写操作， 这带来了一定的开销：对于一个运行着 UNIX 系统的现代 PC 来说， 进程切换通常至少需要花费 300 us 的时间。

- 进程状态图

![img](https://pic2.zhimg.com/80/v2-e88514c2e604c4ac538c402f1788862c_1440w.jpg?source=1940ef5c)

进程的**阻塞**往往个system call紧密相关。一个进程进入waiting状态，要么主动调用wait()或者sleep()，要么就是调用system call。而 System Call 因为涉及到了 I/O 操作， 不能立即完成， 于是内核就会先将该进程置为等待状态， 调度其他进程的运行， 等到 它所请求的 I/O 操作完成了以后， 再将其状态更改回 ready 。

- **非阻塞I/O 系统调用( nonblocking system call )** 和 **异步I/O系统调用 （asychronous system call）**的区别是：
  - 一个**非阻塞I/O 系统调用 read()** 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。
  - **异步I/O系统调用** read（）结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。

