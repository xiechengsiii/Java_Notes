## 操作系统概述

- 操作系统的功能和目标---作为用户和计算机硬件之间的接口

![image-20200812092959535](E:\Typora\imgs\image-20200812092959535.png)

联机命令接口：cmd  命令行  也叫交互式命令接口

脱机命令接口：.bat 文件      也叫批处理命令接口 

程序接口：![image-20200812093348462](E:\Typora\imgs\image-20200812093348462.png)

---

![image-20200812100433005](E:\Typora\imgs\image-20200812100433005.png)

- 异步

  异步是指，在多道程序环境下，允许多个程序并发执行，但由于**资源有限**，进程的执行不是一贯到底的，而是走走停停，已不可预知的速度向前推进，这就是程序的异步性。

  ​	**只有系统有并发性，才可能导致异步性**

##### 操作系统的运行机制和体系结构

![image-20200812154007751](E:\Typora\imgs\image-20200812154007751.png)

**两种指令，两种处理器状态，两种程序**

- 指令是啥？

  是处理器能识别，执行的最基本命令（一连串的二进制）

  分为 **特权指令**   如内存清零指令

  ​		**非特权指令**  运算指令

- 两种处理器状态

  用户态

  核心态（管态）

  ![image-20200812153837452](E:\Typora\imgs\image-20200812153837452.png)

---

- 两种程序

  ![image-20200812153927363](E:\Typora\imgs\image-20200812153927363.png)

---

- 操作系统的内核![image-20200812154217620](E:\Typora\imgs\image-20200812154217620.png)

  分为大内核和为内核：

  ![image-20200812154634903](E:\Typora\imgs\image-20200812154634903.png)



![image-20200812154338913](E:\Typora\imgs\image-20200812154338913.png)



## 进程与线程

##### 中断和异常

![image-20200812225943441](E:\Typora\imgs\image-20200812225943441.png)

PSW:程序状态字寄存器

- 中断的分类

  ![image-20200812230859325](E:\Typora\imgs\image-20200812230859325.png)

---

![image-20200812231003545](E:\Typora\imgs\image-20200812231003545.png)

外中断的处理过程

![image-20200812231237745](E:\Typora\imgs\image-20200812231237745.png)

中断处理程序属于操作系统内核的，运行在核心态

##### 系统调用

​	是操作系统提供给应用程序（程序员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得OS的服务

- 为什么要提供系统调用?

  系统中的各种共享资源都由操作系统统一掌管，而不能直接由应用程序操作。因此，在用户程序中，凡是和**资源相关**的（存储分配， IO，文件管理等），都必须通过系统调用的方式向OS提出服务请求，由OS代为完成。这样可以保证<font color = red>系统的稳定性和安全性</font>，防止用户进行非法操作。

![image-20200813082707042](E:\Typora\imgs\image-20200813082707042.png)

​	系统调用需要在核心态进行。

​	凡是和资源有关的操作以及影响到其他进程的操作，都需要OS介入，即需要系统调用完成

- 系统调用和库函数的区别

  ![image-20200813082959119](E:\Typora\imgs\image-20200813082959119.png)

- 系统调用背后的过程

  ![image-20200813083325338](E:\Typora\imgs\image-20200813083325338.png)

  ​	int x  比如 x 是3的话，就是读操作， x是4的话，就是写操作

  传递系统调用参数 :arrow_right: 执行陷入指令（用户态）:arrow_right:  执行系统调用相应的服务程序（核心态）:arrow_right:  返回应用程序

  陷入指令是在用户态进行的，执行trap后，立即引发一个**内中断**，从而CPU进入核心态

  注意，**陷入指令时为一个在用户态执行而不能在核心态执行的指令**

##### 进程

![image-20200813085349771](E:\Typora\imgs\image-20200813085349771.png) 

一般，进程实体简称问进程。创建进程，实际上是创建PCB,	撤销进程是撤销进程实体中的PCB

PCB就是OS对进程进行管理的相关数据存放的地方。

<font color = red>PCB是进程存在的唯一标志</font>

定义：

![image-20200813085739536](E:\Typora\imgs\image-20200813085739536.png)

- 进程的组成

![image-20200813090127406](E:\Typora\imgs\image-20200813090127406.png)

- PCB![image-20200813090202130](E:\Typora\imgs\image-20200813090202130.png)

进程是能独立运行，是系统进行资源分配和调度的一个独立单位，而且是动态的。

- 进程状态的转化

  ![image-20200813093045852](E:\Typora\imgs\image-20200813093045852.png)

---

![image-20200813093214265](E:\Typora\imgs\image-20200813093214265.png)

###### 进程控制

进程控制就是对系统中的所有进程实施有效管理，其实就是实现进程的状态转换

![image-20200813093710407](E:\Typora\imgs\image-20200813093710407.png)

 如果PCB从一个阻塞队列转移到就绪队列，但是PCB中的状态标志并没有更新成相应的新的状态，就会出现问题。为了解决这种情况，使用**原语**实现进程控制。

![image-20200813094012738](E:\Typora\imgs\image-20200813094012738.png)

执行关中断指令后，如果这时候有外部中断信号，是会被忽略的，也就是当前进程不会被中断，只有当开中断指令执行后，才重新开始相应中断信号。

![image-20200813094535914](E:\Typora\imgs\image-20200813094535914.png)

---

![image-20200813094817013](E:\Typora\imgs\image-20200813094817013.png)

---

![image-20200813094922462](E:\Typora\imgs\image-20200813094922462.png)

---

![image-20200813095040097](E:\Typora\imgs\image-20200813095040097.png)

###### 进程通信

![image-20200813095313594](E:\Typora\imgs\image-20200813095313594.png)

- 共享存储![image-20200813095458018](E:\Typora\imgs\image-20200813095458018.png)

- 管道通信![image-20200813095805169](E:\Typora\imgs\image-20200813095805169.png)

- 消息传递![image-20200813100002004](E:\Typora\imgs\image-20200813100002004.png)

##### 线程

引入线程后，进程时资源分配的基本单位，线程是调度的基本单位

![image-20200813100701633](E:\Typora\imgs\image-20200813100701633.png)

- 线程的属性![image-20200813100852894](E:\Typora\imgs\image-20200813100852894.png)

- 线程的实现方式

  - 用户级线程

  ![image-20200813100945098](E:\Typora\imgs\image-20200813100945098.png)

  - 内核级线程

    ![image-20200813101028182](E:\Typora\imgs\image-20200813101028182.png)

![image-20200813101129978](E:\Typora\imgs\image-20200813101129978.png)

- 多线程模型

  多对一模型

  ![image-20200813101405675](E:\Typora\imgs\image-20200813101405675.png)

  当一个内核级线程正在处理某个用户级线程的逻辑时，**用户级线程阻塞会导致内核级线程阻塞**，由于进程只对应这一个内核心线程，所以也会导致整个进程阻塞

  一对一模型

  ![image-20200813101706561](E:\Typora\imgs\image-20200813101706561.png)

  多对多模型

  ![image-20200813101808030](E:\Typora\imgs\image-20200813101808030.png)

##### 调度

- 高级调度  （作业调度）![image-20200813102529823](E:\Typora\imgs\image-20200813102529823.png)
- 中级调度 （内存调度）![image-20200813102516796](E:\Typora\imgs\image-20200813102516796.png)

有了挂起状态，有一种七状态模型：

![image-20200813102924960](E:\Typora\imgs\image-20200813102924960.png)



- 低级调度  （进程调度）

![image-20200813103105142](E:\Typora\imgs\image-20200813103105142.png)

三种调度的对比

![image-20200813103128299](E:\Typora\imgs\image-20200813103128299.png)

###### 进程调度的时机，切换

- 什么时候进行进程调度

  ![image-20200813104411111](E:\Typora\imgs\image-20200813104411111.png)

---

![image-20200813105557168](E:\Typora\imgs\image-20200813105557168.png)

![image-20200813105305393](E:\Typora\imgs\image-20200813105305393.png)

  

###### 调度的方式

![image-20200813105900853](E:\Typora\imgs\image-20200813105900853.png)

###### 进程切换

进程切换主要完成了：

- 对原来运行进程各种数据的保存

- 对新的进程各种数据的恢复， 如程序计数器，程序状态字，各种数据寄存器等信息，这些信息一般保存在PCB

  **切换是有代价的， 如果过于频繁的进行进程调度，切换，会使系统大部分时间花在进程切换上，而用于执行进程的时间减少**

###### 调度算法

几个指标：

![image-20200813111401343](E:\Typora\imgs\image-20200813111401343.png)

如果一个作业的运行时间很短，但是周转时间很长，那么用户的体验是不好的（虽然可能周转时间和其他作业一样）， 因此需要用带权周转时间来评价。(排队上厕所的比喻)

**几种调度算法**

- 先来先服务    FCFS  first come first serve  

  ![image-20200813204444451](E:\Typora\imgs\image-20200813204444451.png)

---

![image-20200813204811486](E:\Typora\imgs\image-20200813204811486.png)

- 短作业优先  SJF shortest job first

![image-20200813205106835](E:\Typora\imgs\image-20200813205106835.png)

抢占式SJF：（也叫最短剩余时间优先算法SRNT）

![image-20200813205411893](E:\Typora\imgs\image-20200813205411893.png)

对比非抢占式的SJF，抢占式的上述几个几个指标更低

![image-20200813205915425](E:\Typora\imgs\image-20200813205915425.png)

---

![image-20200813210026775](E:\Typora\imgs\image-20200813210026775.png)

- 高响应比优先   HRRN Highest response ratio next

  ![image-20200813210444390](E:\Typora\imgs\image-20200813210444390.png)

---

![image-20200813210534937](E:\Typora\imgs\image-20200813210534937.png)

几个算法的比较

![image-20200813210633109](E:\Typora\imgs\image-20200813210633109.png)

---

![image-20200813210832879](E:\Typora\imgs\image-20200813210832879.png)

- 时间片轮转  RR  Round-Robin

  ![image-20200813211512927](E:\Typora\imgs\image-20200813211512927.png)

---

![image-20200813211746608](E:\Typora\imgs\image-20200813211746608.png)

另一方面，如果时间片太小，会导致进程频繁切换，系统花费大量时间处理切换（保存，恢复运行环境），会导致实际有用于执行的时间比例减少，因此时间片也不能太小。一般来说，设计时间片要让切换进程的开销占比不超过1%。

![image-20200813212149567](E:\Typora\imgs\image-20200813212149567.png)

- 优先级调度算法

  ![image-20200813212605797](E:\Typora\imgs\image-20200813212605797.png)

抢占式

![image-20200813212736530](E:\Typora\imgs\image-20200813212736530.png)

![image-20200813213053626](E:\Typora\imgs\image-20200813213053626.png)

---

![image-20200813213129443](E:\Typora\imgs\image-20200813213129443.png)

- 多级反馈队列调度算法

  ![image-20200813213708193](E:\Typora\imgs\image-20200813213708193.png)

![image-20200813213911786](E:\Typora\imgs\image-20200813213911786.png)

**比较**

![image-20200813214114595](E:\Typora\imgs\image-20200813214114595.png)

##### 进程同步与互斥

**同步**

![image-20200813214518583](E:\Typora\imgs\image-20200813214518583.png)

**互斥**

![image-20200813214704180](E:\Typora\imgs\image-20200813214704180.png)

临界区就是访问临界资源的那段代码

![image-20200813215110491](E:\Typora\imgs\image-20200813215110491.png)

###### 进程互斥的软件实现方法

- 单标志法

  ![image-20200813215635725](E:\Typora\imgs\image-20200813215635725.png)

这种算法，一定是按P0 -- P1 --P0 --P1访问顺序访问临界区，如果P0一直不访问临界区，那么虽然临界区空闲，但是P1也无法访问，就违背了“空闲让进”原则

- 双标志先检查法

  ![image-20200813220252822](E:\Typora\imgs\image-20200813220252822.png)

- 双标志后检查法

  ![image-20200813220437259](E:\Typora\imgs\image-20200813220437259.png)

- Peterson算法

  ![image-20200813221323151](E:\Typora\imgs\image-20200813221323151.png)

###### 进程互斥的硬件实现方法

- 中断屏蔽方法

​	![image-20200813223125370](E:\Typora\imgs\image-20200813223125370.png)

- TestAndSet指令 

![image-20200813223716335](E:\Typora\imgs\image-20200813223716335.png)

- Swap指令

  ![image-20200813224218034](E:\Typora\imgs\image-20200813224218034.png)

##### 信号量机制

![image-20200813224432357](E:\Typora\imgs\image-20200813224432357.png)

---

![image-20200813225353628](E:\Typora\imgs\image-20200813225353628.png)

- 整型信号量

  ![image-20200813230431378](E:\Typora\imgs\image-20200813230431378.png)

整型信号量存在的问题是不满足让权等待原则

- 记录型信号量

  ![image-20200813231026008](E:\Typora\imgs\image-20200813231026008.png)

![image-20200813231620739](E:\Typora\imgs\image-20200813231620739.png)

![image-20200813231851146](E:\Typora\imgs\image-20200813231851146.png)

满足了“让权等待”原则

- 信号量机制实现进程互斥

![image-20200814095550810](E:\Typora\imgs\image-20200814095550810.png)

- 信号量实现进程同步

  同步：让各并发进程按要求有序地推进

  ![image-20200814100020141](E:\Typora\imgs\image-20200814100020141.png)

![image-20200814100337518](E:\Typora\imgs\image-20200814100337518.png)

总结：

​	**进程互斥**，就把信号量初值设为1， 把临界区看成一种特殊的系统资源，一个时间段只能分给一个进程；

同理，有多少个系统资源，就把信号量的初试值设为多少。申请自愿的时候P操作,释放资源的时候V操作

​	**进程同步**，``semphare = 0``, “前V后P”；



###### 生产者消费者问题

![image-20200815201612418](E:\Typora\imgs\image-20200815201612418.png)

---

![image-20200815201958795](E:\Typora\imgs\image-20200815201958795.png)



###### 多生产者-消费者问题

![image-20200815202905422](E:\Typora\imgs\image-20200815202905422.png)

这个多   指的是多类生产者/消费者

![image-20200815203650506](E:\Typora\imgs\image-20200815203650506.png)

![image-20200815205746534](E:\Typora\imgs\image-20200815205746534.png)

- 吸烟者问题

  ![image-20200815205719681](E:\Typora\imgs\image-20200815205719681.png)

![image-20200815210155849](E:\Typora\imgs\image-20200815210155849.png)

######   读者-写者问题

![image-20200816091235459](E:\Typora\imgs\image-20200816091235459.png)

solution

![image-20200816092107427](E:\Typora\imgs\image-20200816092107427.png)

![image-20200816092728725](E:\Typora\imgs\image-20200816092728725.png)

这里，优先唤醒哪个进程呢？ 信号量中队列里队列头的进程，也就是排队时间最久的线程；FIFO

###### 哲学家进餐问题

![image-20200816093733229](E:\Typora\imgs\image-20200816093733229.png)

第三种:互斥地“拿筷子”

![image-20200816094252976](E:\Typora\imgs\image-20200816094252976.png)

如果遇到了一个进程需要同时持有多个临界资源，可以参考解决“哲学家问题”的思想，注意分析进程之间是否会发生死锁

##### 管程

​	虽然信号量机制就可以实现进程的同步和互斥，但是程序编写困难，容易出错。所以引入管程，一种高级的同步机制，用于解决进程的同步与互斥。

- 定义![image-20200816095340103](E:\Typora\imgs\image-20200816095340103.png)

  类似于自己定义的一个类对象

  管程解决生产者消费者问题：

  ![image-20200816100726316](E:\Typora\imgs\image-20200816100726316.png)

  和Java中的``ReentranLock``很像，这个管程就类似与Java中基于``ReentranLock``实现的``ArrayBlockingQueue``

![image-20200816101120982](E:\Typora\imgs\image-20200816101120982.png)

![image-20200816101155329](E:\Typora\imgs\image-20200816101155329.png)



##### 死锁

​	产生的**必要**条件

- 互斥条件   	资源的使用是互斥的
- 不可剥夺条件   进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
- 请求和保持    进程持有一个资源的同时又请求其他的资源，而请求的资源被其他进程占用
- 循环等待   存在一种进程资源的循环等待， 链中进程所获的的资源都被上一个进程所请求。

![image-20200817100620078](E:\Typora\imgs\image-20200817100620078.png)

**死锁的处理策略**

- 预防死锁

  ​	破会死锁产生的四个必要条件

  ![image-20200817101214757](E:\Typora\imgs\image-20200817101214757.png)

![image-20200817102715385](E:\Typora\imgs\image-20200817102715385.png)

![image-20200817102926908](E:\Typora\imgs\image-20200817102926908.png)

![image-20200817103234379](E:\Typora\imgs\image-20200817103234379.png)

比如对于P3， 先使用7号资源很长一段时间 ，再使用5号资源，但是申请的时候必须再申请7号之前先申请5号，这样就会导致进程P3占有两个资源，但是5号资源可能会保持长期空闲而造成资源的浪费

- 避免死锁

  ​	避免系统进入不安全状态（银行家算法）

  ![image-20200817104057039](E:\Typora\imgs\image-20200817104057039.png)

  ![image-20200817104231125](E:\Typora\imgs\image-20200817104231125.png)

![image-20200817104450213](E:\Typora\imgs\image-20200817104450213.png)

![image-20200817105022557](E:\Typora\imgs\image-20200817105022557.png)

![image-20200817105033441](E:\Typora\imgs\image-20200817105033441.png)

- 死锁的检测和解除

  ​	允许死锁发生，系统负责检测死锁并解除

![image-20200817105525140](E:\Typora\imgs\image-20200817105525140.png)

![image-20200817105841651](E:\Typora\imgs\image-20200817105841651.png)

![image-20200817110002564](E:\Typora\imgs\image-20200817110002564.png)

​	简言之， 就是依次消除与不阻塞进程相连的边，直到无边可消。

![image-20200817110216566](E:\Typora\imgs\image-20200817110216566.png)  