##   内存管理

![image-20200817133249038](E:\Typora\imgs\image-20200817133249038.png)

![image-20200817133622380](E:\Typora\imgs\image-20200817133622380.png)

![image-20200817134149374](E:\Typora\imgs\image-20200817134149374.png)

​	现在都是用的动态重定位

#### 相关概念	

![image-20200817134828671](E:\Typora\imgs\image-20200817134828671.png)

内存保护

![image-20200817135205596](E:\Typora\imgs\image-20200817135205596.png)

#### 内存空间的扩充

###### 	覆盖技术

![image-20200817135455338](E:\Typora\imgs\image-20200817135455338.png)

![image-20200817135654766](E:\Typora\imgs\image-20200817135654766.png)

###### 交换技术

![image-20200817135832027](E:\Typora\imgs\image-20200817135832027.png)

注意进程的PCB是常驻内存你的，因为进程被换出到外存后，需要用PCB记录对应进程在外存中的存放位置，

中级调度（内存调度），就是决定哪个处于挂起状态的进程重新调入内存；

![image-20200817140112581](E:\Typora\imgs\image-20200817140112581.png)

![image-20200817140417066](E:\Typora\imgs\image-20200817140417066.png)

覆盖与交换的区别：覆盖是在同一个进程中的，交换发生再不同进程之间

###### 虚拟存储技术

​	见下面的 -- 虚拟内存一节

#### 内存空间的分配与回收

![image-20200817140828273](E:\Typora\imgs\image-20200817140828273.png)

##### 连续分配管理

###### 单一连续分配

​	![image-20200817141100860](E:\Typora\imgs\image-20200817141100860.png)

###### 固定分区分配

​	![image-20200817141313776](E:\Typora\imgs\image-20200817141313776.png)

![image-20200817141623979](E:\Typora\imgs\image-20200817141623979.png)

###### 动态分区分配

![image-20200817141905481](E:\Typora\imgs\image-20200817141905481.png)

![image-20200817142009375](E:\Typora\imgs\image-20200817142009375.png)

![image-20200817142042697](E:\Typora\imgs\image-20200817142042697.png)

![image-20200817142232194](E:\Typora\imgs\image-20200817142232194.png)

![image-20200817142403246](E:\Typora\imgs\image-20200817142403246.png)

![image-20200817142435101](E:\Typora\imgs\image-20200817142435101.png)

总之就是回收后，将相邻的空闲分区合并

​	动态分区没有内部碎片，但是存在外部碎片：

- 内部碎片  分配给进程的内存区域，有些部分没有利用
- 外部碎片  内存中的某些空闲分区太小而无法利用

![image-20200817142921050](E:\Typora\imgs\image-20200817142921050.png)

动态重定位技术，是最容易实现紧凑技术的。紧凑之后，需要将进程的起始位置修改（存放于进程对应的PCB中）（进程运行之前，会将自己的起始地址取出放在重定位寄存器（或者叫基址寄存器）中）

![image-20200817143411347](E:\Typora\imgs\image-20200817143411347.png)

动态分区分配算法

- 首次适应算法  First Fit

  ![image-20200817143733470](E:\Typora\imgs\image-20200817143733470.png)

  ​	因为每次从链头开始查找，这可能导致低地址部分出现很多很小的空闲分区，而每次分配查找时，都要经过这些分区，增加了查找的开销

- 最佳适应算法 Best Fit

  ![image-20200817144013247](E:\Typora\imgs\image-20200817144013247.png)

- 最坏适应算法

  ![image-20200817144201027](E:\Typora\imgs\image-20200817144201027.png)

- 邻近适应算法

![image-20200817144837789](E:\Typora\imgs\image-20200817144837789.png)

 ![image-20200817144931533](E:\Typora\imgs\image-20200817144931533.png)

##### 非连续内存分配

​	基于分页存储管理实现的。

#### 分页存储管理

![image-20200817220058873](E:\Typora\imgs\image-20200817220058873.png)

![image-20200817220632520](E:\Typora\imgs\image-20200817220632520.png)

![image-20200817221016631](E:\Typora\imgs\image-20200817221016631.png)

![image-20200817224429496](E:\Typora\imgs\image-20200817224429496.png)

![image-20200817224910819](E:\Typora\imgs\image-20200817224910819.png)

![image-20200817225134251](E:\Typora\imgs\image-20200817225134251.png)

![image-20200817225344912](E:\Typora\imgs\image-20200817225344912.png)

​	内存块就是页框

######  基本地址变换机构

​	**页表寄存器**

![image-20200817225903438](E:\Typora\imgs\image-20200817225903438.png)

![image-20200817230409030](E:\Typora\imgs\image-20200817230409030.png)

![image-20200817230635413](E:\Typora\imgs\image-20200817230635413.png)

![image-20200817231033514](E:\Typora\imgs\image-20200817231033514.png)

![image-20200817231222248](E:\Typora\imgs\image-20200817231222248.png)

 整个地址变换过程需要访问两次内存。

###### 具有快表的地址变换机构

- 局部性原理

  ![image-20200817231718974](E:\Typora\imgs\image-20200817231718974.png)



![image-20200817232130896](E:\Typora\imgs\image-20200817232130896.png)

![image-20200818084229278](E:\Typora\imgs\image-20200818084229278.png)

###### 两级页表

- 单级页表存在的问

  ![image-20200818084618940](E:\Typora\imgs\image-20200818084618940.png)

  还有个问题就是，根据局部性原理，进程在一段时间内，只需要访问几个页面就可以正常运行了，没必要将整个页表常驻内存 

  **解决问题1 ：页表项需要连续存放，页表项很大时需要占用很多连续的页框**

![image-20200818085706836](E:\Typora\imgs\image-20200818085706836.png)

**解决问题2：没有表要让整个页表常驻内存**

![image-20200818090505017](E:\Typora\imgs\image-20200818090505017.png)

![image-20200818090924434](E:\Typora\imgs\image-20200818090924434.png)

#### 基本分段存储管理

​	与分页的最大区别就是离散分配时所分配地址空间的基本单位不同

![image-20200818091406841](E:\Typora\imgs\image-20200818091406841.png)

![image-20200818091554869](E:\Typora\imgs\image-20200818091554869.png)

![image-20200818092558145](E:\Typora\imgs\image-20200818092558145.png)

![image-20200818093302464](E:\Typora\imgs\image-20200818093302464.png)

![image-20200818093524390](E:\Typora\imgs\image-20200818093524390.png)

![image-20200818093628396](E:\Typora\imgs\image-20200818093628396.png)

![image-20200818093802717](E:\Typora\imgs\image-20200818093802717.png)

![image-20200818093914425](E:\Typora\imgs\image-20200818093914425.png)

#### 段页式管理方式

​	![image-20200818095118096](E:\Typora\imgs\image-20200818095118096.png)

![image-20200818095302298](E:\Typora\imgs\image-20200818095302298.png)

![image-20200818095606712](E:\Typora\imgs\image-20200818095606712.png)

![image-20200818095818423](E:\Typora\imgs\image-20200818095818423.png)

#### 虚拟内存

​	![image-20200818100440175](E:\Typora\imgs\image-20200818100440175.png)

实际上，虚拟技术的提出是基于局部性原理的

![image-20200818101623813](E:\Typora\imgs\image-20200818101623813.png)

![image-20200818101853798](E:\Typora\imgs\image-20200818101853798.png)

![image-20200818102045389](E:\Typora\imgs\image-20200818102045389.png)

​	请求调页 && 页面置换

###### 请求分页存储管理

​	![image-20200818102435148](E:\Typora\imgs\image-20200818102435148.png)

![image-20200818102930891](E:\Typora\imgs\image-20200818102930891.png)

![image-20200818103204131](E:\Typora\imgs\image-20200818103204131.png)

![image-20200818103301711](E:\Typora\imgs\image-20200818103301711.png)

![image-20200818103342999](E:\Typora\imgs\image-20200818103342999.png)

![image-20200818104018658](E:\Typora\imgs\image-20200818104018658.png)

###### 页面置换算法

​	![image-20200818104810476](E:\Typora\imgs\image-20200818104810476.png)

- 最佳转换算法 OPT

![image-20200818105139710](E:\Typora\imgs\image-20200818105139710.png)

OPT算法可以保证最低的缺页率，但实际上，只有在进程在执行的时候才可以知道下一个将要访问的页面，OS是无法预判页面的访问序列的。<font color = red >OPT只是理想的算法，但是无法实现</font>

- 先进先出置换算法  FIFO

  ![image-20200818105532233](E:\Typora\imgs\image-20200818105532233.png)

  这里，如果分配4个内存块，会发现相同的页面序列，缺页次数却变成了10次：

  **belady异常**    当为进程分配的内存块增大时，缺页次数不增反减的异常现象

  只有FIFO算法会导致belady异常。虽然FIOF实现简单，但是与实际进程运行的规律不适应。比如先进入的页面也有可能被最经常访问，因此算法性能差。

- 最近最久未使用算法 LRU

  ![image-20200818110322421](E:\Typora\imgs\image-20200818110322421.png)

``linkedHashMap`` 可以实现这种算法

- 时钟置换算法 CLOCK   

  也称为NRU,  最近未用算法

![image-20200818134359826](E:\Typora\imgs\image-20200818134359826.png)

![image-20200818134534585](E:\Typora\imgs\image-20200818134534585.png)

![image-20200818134546547](E:\Typora\imgs\image-20200818134546547.png)

###### 页面分配策略

![image-20200818135025316](E:\Typora\imgs\image-20200818135025316.png)

![image-20200818135315715](E:\Typora\imgs\image-20200818135315715.png)

这里的“未锁定的页面”：系统会锁定一些页面，这些页面中的内容不能置换出外存，如重要的内核数据可以设定为“锁定”

- 调入页面的时机

![image-20200818135741148](E:\Typora\imgs\image-20200818135741148.png)

 实际过程中，预调页和请求调页都是结合使用的，预调页用于进程运行前的调入，请求调页则在进程运行期间使用

- 从何处调入页面

  ![image-20200818140229402](E:\Typora\imgs\image-20200818140229402.png)

- 抖动（颠簸）现象

![image-20200818140356591](E:\Typora\imgs\image-20200818140356591.png)

![image-20200818140536357](E:\Typora\imgs\image-20200818140536357.png)

![image-20200818140725657](E:\Typora\imgs\image-20200818140725657.png)